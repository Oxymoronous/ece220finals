RUNNING
;callee set-up of Running Sum’s activation record
;push return value
ADD R6, R6, #-1

;push return address & old frame pointer
ADD R6, R6, #-1
STR R7, R6, #0
ADD R6, R6, #-1
STR R5, R6, #0

;;push local variables & update frame pointer
ADD R6, R6, #-1
ADD R5, R6, #0

;function logic
;;base case (n==1)
LDR R1, R5, #4
ADD R2, R1, #-1
BRz BASE_CASE

;;recursive case
;caller setup for Running(n-1)
;push argument n-1 onto RST
ADD R6, R6, #-1
STR R2, R6, #0
;call Running(n-1)
JSR RUNNING

;caller tear-down for Running(n-1)
;pop Running(n-1)’s return value to R0
LDR R0, R6, #0
ADD R6, R6, #1

;pop Running(n-1)’s argument
ADD R6, R6, #1

;calculate n + Running(n-1)
LDR R1, R5, #4
ADD R0, R1, R0
;store result in fn
STR R0, R5, #0

;ready to return
BRnzp RETURN

BASE_CASE
;set fn = 1
AND R2, R2, #0
ADD R2, R2, #1
STR R2, R5, #0

RETURN
;set return value
LDR R0, R5, #0
STR R0, R5, #3

;callee tear-down of Running(n)’s activation record
;pop local variables
ADD R6, R6, #1

;restore caller’s frame pointer and return address
LDR R5, R6, #0
ADD R6, R6, #1
LDR R7, R6, #0
ADD R6, R6, #1

;return to caller
RET


.END